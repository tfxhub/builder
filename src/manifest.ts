import { writeFile, readFile } from 'fs/promises';
import { join } from 'path';

type PackageMeta = {
    author?: string;
    description?: string;
    version?: string;
};

type FxManifestPrimitive = string | number | boolean;
type FxManifestNestedObject = Record<string, FxManifestPrimitive>;
type FxManifestSubsection = Record<string, FxManifestPrimitive | FxManifestNestedObject>;

export interface FxManifestJson {
    [key: string]: FxManifestPrimitive | FxManifestPrimitive[] | FxManifestSubsection;
}

/**
 * Options for the manifest generation
 */
export interface ManifestOptions {
    /** Working directory (defaults to process.cwd()) */
    cwd?: string;
    /** Path to package.json (relative to cwd) */
    packageJsonPath?: string;
    /** Path to fxmanifest.json (relative to cwd) */
    fxmanifestJsonPath?: string;
    /** Output path for fxmanifest.lua (relative to cwd) */
    outputPath?: string;
    /** Whether to create .yarn.installed file */
    createYarnInstalled?: boolean;
    /** Whether this is a production build */
    production?: boolean;
}

function isPlainObject(value: unknown): value is Record<string, unknown> {
    return typeof value === 'object' && value !== null && !Array.isArray(value);
}

async function readJSON<T = unknown>(filePath: string): Promise<T> {
    const fileContent = await readFile(filePath, 'utf8');
    return JSON.parse(fileContent) as T;
}

/**
 * Generates fxmanifest.lua from fxmanifest.json and package.json
 */
export async function generateFxManifest(options: ManifestOptions = {}): Promise<void> {
    const {
        cwd = process.cwd(),
        packageJsonPath = 'package.json',
        fxmanifestJsonPath = 'fxmanifest.json',
        outputPath = 'fxmanifest.lua',
        createYarnInstalled = true,
        production = false,
    } = options;

    const packageJson = await readJSON<PackageMeta>(join(cwd, packageJsonPath));
    const fxmanifestJson = await readJSON<FxManifestJson>(join(cwd, fxmanifestJsonPath));

    const processedManifest = { ...fxmanifestJson };

    if ('ui_page_dev' in processedManifest) {
        if (production) {
            delete processedManifest.ui_page_dev;
        } else {
            processedManifest.ui_page = processedManifest.ui_page_dev;
            delete processedManifest.ui_page_dev;
        }
    }

    let fxManifest =
        '-- @@@ This file is automatically generated by @tfxhub/builder @@@\n' +
        '-- @@@ Make changes in the fxmanifest.json / package.json files @@@\n\n' +
        `author '${packageJson.author ?? ''}'\n` +
        `description '${packageJson.description ?? ''}'\n` +
        `version '${packageJson.version ?? ''}'\n\n`;

    Object.keys(processedManifest).forEach((key) => {
        const value = processedManifest[key];
        if (Array.isArray(value)) {
            fxManifest += `${key} {\n`;
            value.forEach((item, index) => {
                fxManifest += `\t'${String(item)}'${index === value.length - 1 ? '\n' : ',\n'}`;
            });
            fxManifest += '}\n';
        } else if (isPlainObject(value)) {
            Object.entries(value).forEach(([subKey, subValue]) => {
                fxManifest += `${key} '${subKey}' {\n`;
                if (isPlainObject(subValue)) {
                    Object.entries(subValue).forEach(([innerKey, innerValue]) => {
                        fxManifest += `\t${innerKey} = '${String(innerValue)}'\n`;
                    });
                } else {
                    fxManifest += `\t${subKey} = '${String(subValue)}'\n`;
                }
                fxManifest += '}\n';
            });
        } else {
            fxManifest += `${key} '${String(value)}'\n`;
        }
    });

    await writeFile(join(cwd, outputPath), fxManifest);

    if (createYarnInstalled) {
        await writeFile(
            join(cwd, '.yarn.installed'),
            new Date().toLocaleString('en-US', {
                timeZone: 'UTC',
                timeStyle: 'long',
                dateStyle: 'full',
            }),
        );
    }
}
